<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="ie=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Three.js - Directional Light</title>
      <style>
         * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -applesystem, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
            Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
         }
         html,
         body {
            height: 100vh;
            width: 100vw;
         }
         #threejs-container {
            position: block;
            width: 100%;
            height: 100%;
         }
      </style>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.js"></script>
   </head>
   <body>
   <div id="container"></div>
   </body>
</html>
<script type="module">
         // Adding directional light to the scene
         // The lights falls from the light only in one direction.
         // You can see the position of light using helpers provided in Three.j

         // GUI
         const gui = new dat.GUI()
         // sizes
         let width = window.innerWidth
         let height = window.innerHeight
         // scene
         const scene = new THREE.Scene()
         scene.background = new THREE.Color(0x262626)
         // camera
         const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000)
         camera.position.set(0, 0, 10)
         const camFolder = gui.addFolder('Camera')
         camFolder.add(camera.position, 'z', 10, 80, 1)
         camFolder.open()
         // lights
         const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
         scene.add(ambientLight)
         const light = new THREE.DirectionalLight()
         light.position.set(2.5, 2, 2)
         light.castShadow = true
         light.shadow.mapSize.width = 512
         light.shadow.mapSize.height = 512
         light.shadow.camera.near = 0.5
         light.shadow.camera.far = 100
         scene.add(light)
         const helper = new THREE.DirectionalLightHelper(light)
         scene.add(helper)
         // light controls
         const lightColor = {
            color: light.color.getHex()
         }
         const lightFolder = gui.addFolder('Directional Light')
         lightFolder.addColor(lightColor, 'color').onChange(() => {
         light.color.set(lightColor.color)
         })
         lightFolder.add(light, 'intensity', 0, 1, 0.01)
         lightFolder.open()
         const directionalLightFolder = gui.addFolder('Position of Light')
         directionalLightFolder.add(light.position, 'x', -10, 10, 0.1)
         directionalLightFolder.add(light.position, 'y', -10, 10, 0.1)
         directionalLightFolder.add(light.position, 'z', -10, 10, 0.1)
         directionalLightFolder.open()
         // plane
         const planeGeometry = new THREE.PlaneGeometry(100, 20)
         const plane = new THREE.Mesh(planeGeometry, new THREE.MeshPhongMaterial({ color: 0xffffff }))
         plane.rotateX(-Math.PI / 2)
         plane.position.y = -1.75
         plane.receiveShadow = true
         scene.add(plane)
         // cube



//////////////////////////////////////////////////////////////////////////////////////////////

const textureCrisis = new THREE.TextureLoader().load( "crisis.png" );
const textureFaceSmile = new THREE.TextureLoader().load( "face-smile.png" );
const textureFaceSad = new THREE.TextureLoader().load( "face-sad.png" );

var r1 = 10;
var r2 = 1;

var rLarge = 10;
var hLarge = 8;

var rNeck = 6.1;
var hNeck = 3;

var rBoop = 6;
var hBoop = 3;

var rCurve = (rLarge - rBoop);

var delta = 0.3;
var cylinderAngleDelta = delta / rLarge;
var curveAngleDelta = delta / rCurve;

var PI2 = 2 * Math.PI;
var PIper2 = Math.PI / 2;
var FaceFrom = - Math.PI / 4;
var FaceTo = Math.PI / 4;
var FaceWidth = FaceTo - FaceFrom;
var HeadFrom = Math.PI / 4;
var HeadTo = PI2 - Math.PI / 4;

// -----------------------------------------------------------

var headVerticesRaw = [];
var headIndices = [];
var headIndex = 0;

function partNeckCylinder() {
  var finish = false;

  var cylinderAngle;
  for(cylinderAngle = 0; ; cylinderAngle += cylinderAngleDelta) {
    if(cylinderAngle >= PI2) {
      cylinderAngle = PI2;
      finish = true;
    }

    headVerticesRaw.push(Math.cos(cylinderAngle) * rNeck);
    headVerticesRaw.push(0);
    headVerticesRaw.push(Math.sin(cylinderAngle) * rNeck);
    headVerticesRaw.push(Math.cos(cylinderAngle) * rNeck);
    headVerticesRaw.push(hNeck);
    headVerticesRaw.push(Math.sin(cylinderAngle) * rNeck);

    if(finish) {
      headIndex += 2;
      break;
    } else {
      headIndices.push(headIndex);
      headIndices.push(headIndex+1);
      headIndices.push(headIndex+2);
      headIndices.push(headIndex+2);
      headIndices.push(headIndex+1);
      headIndices.push(headIndex+3);
      headIndex += 2;
    }
  }
}

function partLowerCurve() {
  var finishCurve = false;
  var numberOfIndicesInARow = 0;
  var rowIndex = 0;
  var currentIndex = headIndex;

  var curveAngle;
  for(curveAngle = 0; ; curveAngle += curveAngleDelta) {

      if(curveAngle >= PIper2) {
        curveAngle = PIper2;
        finishCurve = true;
      }

      var finish = false;

      var cylinderAngle;
      for(cylinderAngle = 0; ; cylinderAngle += cylinderAngleDelta) {
        if(cylinderAngle >= PI2) {
          cylinderAngle = PI2;
          finish = true;
        }

        headVerticesRaw.push(Math.cos(cylinderAngle) * (rLarge - rCurve * (1- Math.cos(curveAngle))));
        headVerticesRaw.push(hNeck + rCurve * (1 - Math.sin(curveAngle)));
        headVerticesRaw.push(Math.sin(cylinderAngle) * (rLarge - rCurve * (1- Math.cos(curveAngle))));
        headIndex++;

        if(curveAngle <= 0) { numberOfIndicesInARow++; }
        if(curveAngle > 0 && cylinderAngle > 0) {
            headIndices.push(currentIndex);
            headIndices.push(currentIndex + 1);
            headIndices.push(currentIndex + numberOfIndicesInARow);
            headIndices.push(currentIndex + numberOfIndicesInARow);
            headIndices.push(currentIndex + 1);
            headIndices.push(currentIndex + numberOfIndicesInARow + 1);
            currentIndex++;
        }

        if(finish) {
          break;
        }

      } // end for cylinderAngle

      if(finishCurve) {
        break;
      }

      rowIndex++;
  } // end for curveAngle

}

function partLargeCylinder() {
  var finish = false;

  var cylinderAngle;
  for(cylinderAngle = HeadFrom; ; cylinderAngle += cylinderAngleDelta) {
    if(cylinderAngle >= HeadTo) {
      cylinderAngle = HeadTo;
      finish = true;
    }

    headVerticesRaw.push(Math.cos(cylinderAngle) * rLarge);
    headVerticesRaw.push(hNeck + rCurve);
    headVerticesRaw.push(Math.sin(cylinderAngle) * rLarge);
    headVerticesRaw.push(Math.cos(cylinderAngle) * rLarge);
    headVerticesRaw.push(hNeck + rCurve + hLarge);
    headVerticesRaw.push(Math.sin(cylinderAngle) * rLarge);

    if(finish) {
      headIndex += 2;
      break;
    } else {
      headIndices.push(headIndex);
      headIndices.push(headIndex+1);
      headIndices.push(headIndex+2);
      headIndices.push(headIndex+2);
      headIndices.push(headIndex+1);
      headIndices.push(headIndex+3);
      headIndex += 2;
    }
  }
}

function partUpperCurve() {
  var finishCurve = false;
  var numberOfIndicesInARow = 0;
  var rowIndex = 0;
  var currentIndex = headIndex;

  var curveAngle;
  for(curveAngle = 0; ; curveAngle += curveAngleDelta) {

      if(curveAngle >= PIper2) {
        curveAngle = PIper2;
        finishCurve = true;
      }

      var finish = false;

      var cylinderAngle;
      for(cylinderAngle = 0; ; cylinderAngle += cylinderAngleDelta) {
        if(cylinderAngle >= PI2) {
          cylinderAngle = PI2;
          finish = true;
        }

        headVerticesRaw.push(Math.cos(cylinderAngle) * (rLarge - rCurve + rCurve * Math.cos(curveAngle)));
        headVerticesRaw.push(hNeck + rCurve + hLarge + rCurve * Math.sin(curveAngle));
        headVerticesRaw.push(Math.sin(cylinderAngle) * (rLarge - rCurve + rCurve * Math.cos(curveAngle)));
        headIndex++;

        if(curveAngle <= 0) { numberOfIndicesInARow++; }
        if(curveAngle > 0 && cylinderAngle > 0) {
            headIndices.push(currentIndex);
            headIndices.push(currentIndex + numberOfIndicesInARow);
            headIndices.push(currentIndex + 1);
            headIndices.push(currentIndex + 1);
            headIndices.push(currentIndex + numberOfIndicesInARow);
            headIndices.push(currentIndex + numberOfIndicesInARow + 1);
            currentIndex++;
        }

        if(finish) {
          break;
        }

      } // end for cylinderAngle

      if(finishCurve) {
        break;
      }

      rowIndex++;
  } // end for curveAngle

}

function partBoopCylinder() {
  var finish = false;

  var cylinderAngle;
  for(cylinderAngle = 0; ; cylinderAngle += cylinderAngleDelta) {
    if(cylinderAngle >= PI2) {
      cylinderAngle = PI2;
      finish = true;
    }

    headVerticesRaw.push(Math.cos(cylinderAngle) * rBoop);
    headVerticesRaw.push(hNeck + rCurve + hLarge + rCurve);
    headVerticesRaw.push(Math.sin(cylinderAngle) * rBoop);
    headVerticesRaw.push(Math.cos(cylinderAngle) * rBoop);
    headVerticesRaw.push(hNeck + rCurve + hLarge + rCurve + hBoop);
    headVerticesRaw.push(Math.sin(cylinderAngle) * rBoop);

    if(finish) {
      headIndex += 2;
      break;
    } else {
      headIndices.push(headIndex);
      headIndices.push(headIndex+1);
      headIndices.push(headIndex+2);
      headIndices.push(headIndex+2);
      headIndices.push(headIndex+1);
      headIndices.push(headIndex+3);
      headIndex += 2;
    }
  }
}

function partBottom() {
  var y = 0.1;
  headVerticesRaw.push(0);
  headVerticesRaw.push(y);
  headVerticesRaw.push(0);

  var centerIndex = headIndex;
  headIndex++;

  var firstRow = true;
  var finishRadius = false;
  var numberOfIndicesInARow = 0;
  var rowIndex = 0;
  var currentIndex = headIndex;

  var radius;
  for(radius = delta; ; radius += delta) {

      if(radius >= rBoop) {
        radius = rBoop;
        finishRadius = true;
      }

      var finish = false;

      var cylinderAngle;
      for(cylinderAngle = 0; ; cylinderAngle += cylinderAngleDelta) {
        if(cylinderAngle >= PI2) {
          cylinderAngle = PI2;
          finish = true;
        }

        headVerticesRaw.push(Math.cos(cylinderAngle) * radius);
        headVerticesRaw.push(y);
        headVerticesRaw.push(Math.sin(cylinderAngle) * radius);

        headIndex++;

        if(firstRow) {
          numberOfIndicesInARow++;
          if(cylinderAngle > 0) {
            headIndices.push(centerIndex);
            headIndices.push(currentIndex-1);
            headIndices.push(currentIndex);
          }
        }

        if(!firstRow && cylinderAngle > 0) {
            headIndices.push(currentIndex - numberOfIndicesInARow -1);
            headIndices.push(currentIndex - 1);
            headIndices.push(currentIndex - numberOfIndicesInARow);
            headIndices.push(currentIndex - numberOfIndicesInARow);
            headIndices.push(currentIndex - 1);
            headIndices.push(currentIndex);
        }

        ++currentIndex;

        if(finish) {
          break;
        }

      } // end for cylinderAngle

      if(finishRadius) {
        break;
      }

      firstRow = false;
      rowIndex++;
  } // end for curveAngle

}

partNeckCylinder();
partLowerCurve();
partLargeCylinder();
partUpperCurve();
partBoopCylinder();
partBottom();

const headGeometry = new THREE.BufferGeometry();
const headVertices = new Float32Array(headVerticesRaw);
headGeometry.setIndex(headIndices);
headGeometry.setAttribute('position', new THREE.BufferAttribute(headVertices, 3));
headGeometry.computeVertexNormals();
const headMaterial = new THREE.MeshPhongMaterial( { map: textureCrisis, ambient: 0x050505, specular: 0x555555, shininess: 30 });
const headMesh = new THREE.Mesh(headGeometry, headMaterial);
headMesh.castShadow = true;
scene.add(headMesh);

// ---------------------------------------------

var faceVerticesRaw = [];
var faceTextureRaw = [];
var faceIndices = [];
var faceIndex = 0;

function partFace() {
  var finish = false;

  var cylinderAngle;
  for(cylinderAngle = FaceFrom; ; cylinderAngle += cylinderAngleDelta) {
    if(cylinderAngle >= FaceTo) {
      cylinderAngle = FaceTo;
      finish = true;
    }

    var u = (cylinderAngle - FaceFrom) / FaceWidth;

    faceVerticesRaw.push(Math.cos(cylinderAngle) * rLarge);
    faceVerticesRaw.push(hNeck + rCurve);
    faceVerticesRaw.push(Math.sin(cylinderAngle) * rLarge);

    faceTextureRaw.push(u);
    faceTextureRaw.push(0.05);

    faceVerticesRaw.push(Math.cos(cylinderAngle) * rLarge);
    faceVerticesRaw.push(hNeck + rCurve + hLarge);
    faceVerticesRaw.push(Math.sin(cylinderAngle) * rLarge);

    faceTextureRaw.push(u);
    faceTextureRaw.push(0.95);

    if(finish) {
      faceIndex += 2;
      break;
    } else {
      faceIndices.push(faceIndex);
      faceIndices.push(faceIndex+1);
      faceIndices.push(faceIndex+2);
      faceIndices.push(faceIndex+2);
      faceIndices.push(faceIndex+1);
      faceIndices.push(faceIndex+3);
      faceIndex += 2;
    }
  }

}

partFace();

const faceGeometry = new THREE.BufferGeometry();
const faceVertices = new Float32Array(faceVerticesRaw);
faceGeometry.setIndex(faceIndices);
faceGeometry.setAttribute('position', new THREE.BufferAttribute(faceVertices, 3));
faceGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(faceTextureRaw), 2));
faceGeometry.computeVertexNormals();
const faceMaterial = new THREE.MeshPhongMaterial( { map: textureFaceSmile, ambient: 0x050505, specular: 0x555555, shininess: 30 });
const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
faceMesh.castShadow = true;
scene.add(faceMesh);

// ----------------------------------------------

var topVerticesRaw = [];
var topTextureRaw = [];
var topIndices = [];
var topIndex = 0;

function partTop() {
  var y = hNeck + rCurve + hLarge + rCurve + hBoop;
  topVerticesRaw.push(0);
  topVerticesRaw.push(y);
  topVerticesRaw.push(0);

  topTextureRaw.push(0.5);
  topTextureRaw.push(0.5);

  var centerIndex = topIndex;
  topIndex++;

  var firstRow = true;
  var finishRadius = false;
  var numberOfIndicesInARow = 0;
  var rowIndex = 0;
  var currentIndex = topIndex;

  var radius;
  for(radius = delta; ; radius += delta) {

      if(radius >= rBoop) {
        radius = rBoop;
        finishRadius = true;
      }

      var finish = false;

      var cylinderAngle;
      for(cylinderAngle = 0; ; cylinderAngle += cylinderAngleDelta) {
        if(cylinderAngle >= PI2) {
          cylinderAngle = PI2;
          finish = true;
        }

        topVerticesRaw.push(Math.cos(cylinderAngle) * radius);
        topVerticesRaw.push(y);
        topVerticesRaw.push(Math.sin(cylinderAngle) * radius);

        topTextureRaw.push(0.5 - Math.sin(cylinderAngle) * (0.5 * radius / rBoop));
        topTextureRaw.push(0.5 - Math.cos(cylinderAngle) * (0.5 * radius / rBoop));

        topIndex++;

        if(firstRow) {
          numberOfIndicesInARow++;
          if(cylinderAngle > 0) {
            topIndices.push(centerIndex);
            topIndices.push(currentIndex);
            topIndices.push(currentIndex-1);
          }
        }

        if(!firstRow && cylinderAngle > 0) {
            topIndices.push(currentIndex - numberOfIndicesInARow -1);
            topIndices.push(currentIndex - numberOfIndicesInARow);
            topIndices.push(currentIndex - 1);
            topIndices.push(currentIndex - 1);
            topIndices.push(currentIndex - numberOfIndicesInARow);
            topIndices.push(currentIndex);
        }

        ++currentIndex;

        if(finish) {
          break;
        }

      } // end for cylinderAngle

      if(finishRadius) {
        break;
      }

      firstRow = false;
      rowIndex++;
  } // end for curveAngle

}

partTop();

const topGeometry = new THREE.BufferGeometry();
topGeometry.setIndex(topIndices);
topGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(topVerticesRaw), 3));
topGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(topTextureRaw), 2));
topGeometry.computeVertexNormals();
const topMaterial = new THREE.MeshPhongMaterial( { map: textureCrisis, ambient: 0x050505, specular: 0x555555, shininess: 30 });
const topMesh = new THREE.Mesh(topGeometry, topMaterial);
topMesh.castShadow = true;
scene.add(topMesh);

//////////////////////////////////////////////////////////////////////////////////////////////



topMesh.castShadow = true;
topMesh.receiveShadow = true
topMesh.position.set(0, 0.5, 0)
topMesh.scale.set(0.1, 0.05, 0.1)
faceMesh.castShadow = true;
faceMesh.receiveShadow = true
faceMesh.position.set(0, 0.5, 0)
faceMesh.scale.set(0.1, 0.05, 0.1)
headMesh.castShadow = true;
headMesh.receiveShadow = true
headMesh.position.set(0, 0.5, 0)
headMesh.scale.set(0.1, 0.05, 0.1)



         const materialFolder = gui.addFolder('Material')
         materialFolder.add(topMaterial, 'wireframe')
         materialFolder.open()

         // responsiveness
         window.addEventListener('resize', () => {
            width = window.innerWidth
            height = window.innerHeight
            camera.aspect = width / height
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
            renderer.render(scene, camera)
         })
         // renderer
         const renderer = new THREE.WebGL1Renderer()
         renderer.setSize(window.innerWidth, window.innerHeight)
         renderer.shadowMap.enabled = true
         renderer.shadowMap.type = THREE.PCFSoftShadowMap
         renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
         // animation
         function animate() {
            requestAnimationFrame(animate)
            topMesh.rotation.x += 0.005
            topMesh.rotation.y += 0.01
            faceMesh.rotation.x += 0.005
            faceMesh.rotation.y += 0.01
            headMesh.rotation.x += 0.005
            headMesh.rotation.y += 0.01
            renderer.render(scene, camera)
         }
         // rendering the scene
         const container = document.querySelector('#container')
         container.append(renderer.domElement)
         renderer.render(scene, camera)
         animate()
      </script>
